import { readFileSync, existsSync, readdirSync, statSync } from 'fs'
import { join, relative, extname, resolve } from 'path'
import ts from 'typescript'

export class TypeAnalyzer {
  constructor(options = {}) {
    // ÂÆâÂÖ®ÁöÑÂèÇÊï∞Â§ÑÁêÜ
    this.options = this.normalizeOptions(options)
    this.resetData()
  }

  normalizeOptions(options) {
    const defaultInclude = ['src/**/*.{ts,tsx,vue}']
    const defaultExclude = [
      'node_modules', 'dist', '.git', 'build', 'coverage',
      '**/*.d.ts', '**/*.test.{ts,tsx}', '**/*.spec.{ts,tsx}'
    ]

    // ÂÆâÂÖ®Âú∞Â§ÑÁêÜ include
    let include = defaultInclude
    if (options.include) {
      if (typeof options.include === 'string') {
        include = options.include.split(',').map(s => s.trim()).filter(Boolean)
      } else if (Array.isArray(options.include)) {
        include = options.include
      }
    }

    // ÂÆâÂÖ®Âú∞Â§ÑÁêÜ exclude
    let exclude = defaultExclude
    if (options.exclude) {
      if (typeof options.exclude === 'string') {
        exclude = options.exclude.split(',').map(s => s.trim()).filter(Boolean)
      } else if (Array.isArray(options.exclude)) {
        exclude = options.exclude
      }
    }

    return {
      rootDir: options.rootDir || process.cwd(),
      include,
      exclude,
      verbose: Boolean(options.verbose),
      ignorePatterns: options.ignorePatterns || [
        /^Props$/, /^Emits$/, /^Slots$/, /^Expose$/,
        /Props$/, /Emits$/, /Events?$/, /State$/
      ],
    }
  }

  resetData() {
    this.typeDefinitions = new Map()
    this.typeUsages = new Map()
    this.duplicateTypes = new Map()
    this.unusedTypes = new Set()
    this.errors = []
    this.warnings = []
    this.sourceFiles = []
    this.program = null
  }

  async analyze() {
    try {
      if (this.options.verbose) {
        console.log('üîç  ÂºÄÂßãÂàÜÊûê TypeScript Á±ªÂûã...')
        console.log(`üìÇ  È°πÁõÆÊ†πÁõÆÂΩï: ${this.options.rootDir}`)
      }

      await this.scanSourceFiles()
      await this.createTypeScriptProgram()
      await this.analyzeTypeDefinitions()
      await this.analyzeTypeUsages()
      await this.detectUnusedTypes()
      await this.runTypeChecking()

      return this.generateReport()
    } catch (error) {
      console.error('‚ùå  ÂàÜÊûêËøáÁ®ãÂá∫Èîô:', error.message)
      if (this.options.verbose) {
        console.error(error.stack)
      }
      throw error
    }
  }

  async scanSourceFiles() {
    try {
      // ‰ºòÂÖàÊâ´Êèè src ÁõÆÂΩï
      const srcDir = join(this.options.rootDir, 'src')
      const scanRoot = existsSync(srcDir) ? srcDir : this.options.rootDir
      
      this.sourceFiles = this.scanDirectory(scanRoot)
        .filter(file => this.isTypeScriptFile(file))
        .filter(file => this.shouldIncludeFile(file))

      if (this.options.verbose) {
        console.log(`üìÑ  Êâ´ÊèèÂà∞ ${this.sourceFiles.length} ‰∏™Ê∫êÊñá‰ª∂`)
        if (this.sourceFiles.length === 0) {
          console.log('‚ö†Ô∏è  Êú™ÊâæÂà∞Ê∫êÊñá‰ª∂ÔºåËØ∑Ê£ÄÊü•È°πÁõÆÁªìÊûÑ')
        }
      }
    } catch (error) {
      throw new Error(`Êñá‰ª∂Êâ´ÊèèÂ§±Ë¥•: ${error.message}`)
    }
  }

  scanDirectory(dir) {
    const files = []
    try {
      if (!existsSync(dir)) return files

      const items = readdirSync(dir)
      for (const item of items) {
        if (item.startsWith('.')) continue
        
        const fullPath = join(dir, item)
        try {
          const stat = statSync(fullPath)
          
          if (stat.isDirectory()) {
            if (!this.shouldExcludeDirectory(item)) {
              files.push(...this.scanDirectory(fullPath))
            }
          } else {
            files.push(fullPath)
          }
        } catch (e) {
          // ÂøΩÁï•Âçï‰∏™Êñá‰ª∂/ÁõÆÂΩïÁöÑÊùÉÈôêÈîôËØØ
          continue
        }
      }
    } catch (error) {
      // ÂøΩÁï•ÁõÆÂΩïËÆøÈóÆÈîôËØØ
    }
    return files
  }

  isTypeScriptFile(file) {
    return ['.ts', '.tsx', '.vue'].includes(extname(file))
  }

  shouldExcludeDirectory(dirName) {
    const excludeDirs = ['node_modules', 'dist', 'build', 'coverage', '.git', '.svn']
    return excludeDirs.includes(dirName)
  }

  shouldIncludeFile(file) {
    try {
      const relativePath = relative(this.options.rootDir, file).replace(/\\/g, '/')
      
      // Âü∫Êú¨ÊéíÈô§ËßÑÂàô
      if (file.endsWith('.d.ts') || 
          relativePath.includes('node_modules') ||
          /\.(test|spec)\.(ts|tsx)$/.test(file)) {
        return false
      }
      
      // Ê£ÄÊü•Áî®Êà∑ÂÆö‰πâÁöÑÊéíÈô§ËßÑÂàô
      return !this.options.exclude.some(pattern => {
        if (pattern.includes('*')) {
          try {
            const regex = new RegExp(
              '^' + pattern
                .replace(/\*\*/g, '.*')
                .replace(/\*/g, '[^/]*')
                .replace(/\./g, '\\.')
                .replace(/\?/g, '.') + '$'
            )
            return regex.test(relativePath)
          } catch (e) {
            return false
          }
        }
        return relativePath.includes(pattern)
      })
    } catch (error) {
      return false
    }
  }

  async createTypeScriptProgram() {
    try {
      const compilerOptions = this.getCompilerOptions()
      const tsFiles = this.sourceFiles.filter(f => f.endsWith('.ts') || f.endsWith('.tsx'))
      
      if (tsFiles.length > 0) {
        this.program = ts.createProgram(tsFiles, compilerOptions)
        
        if (this.options.verbose) {
          console.log(`üîß  ÂàõÂª∫ TypeScript Á®ãÂ∫è: ${tsFiles.length} ‰∏™Êñá‰ª∂`)
        }
      } else {
        if (this.options.verbose) {
          console.log('‚ö†Ô∏è  Êú™ÊâæÂà∞ TypeScript Êñá‰ª∂')
        }
      }
    } catch (error) {
      if (this.options.verbose) {
        console.warn('‚ö†Ô∏è  ÂàõÂª∫ TypeScript Á®ãÂ∫èÂ§±Ë¥•:', error.message)
      }
    }
  }

  getCompilerOptions() {
    const defaultOptions = {
      target: ts.ScriptTarget.ES2020,
      lib: ['ES2020', 'DOM'],
      module: ts.ModuleKind.ESNext,
      moduleResolution: ts.ModuleResolutionKind.NodeJs,
      esModuleInterop: true,
      allowSyntheticDefaultImports: true,
      resolveJsonModule: true,
      skipLibCheck: true,
      skipDefaultLibCheck: true,
      noEmit: true,
      strict: false, // Èôç‰Ωé‰∏•Ê†ºÂ∫¶ÔºåÂáèÂ∞ëÈÖçÁΩÆÁõ∏ÂÖ≥ÈîôËØØ
      allowJs: false,
      baseUrl: this.options.rootDir,
      paths: { '@/*': ['src/*'] }
    }

    // Â∞ùËØïËØªÂèñÈ°πÁõÆÈÖçÁΩÆ
    try {
      const configPath = ts.findConfigFile(this.options.rootDir, ts.sys.fileExists, 'tsconfig.json')
      if (configPath) {
        const configFile = ts.readConfigFile(configPath, ts.sys.readFile)
        if (!configFile.error) {
          const parsedConfig = ts.parseJsonConfigFileContent(
            configFile.config,
            ts.sys,
            this.options.rootDir
          )
          
          return {
            ...defaultOptions,
            ...parsedConfig.options,
            // ‰øùÊåÅÂÖ≥ÈîÆËÆæÁΩÆ
            noEmit: true,
            skipLibCheck: true,
            skipDefaultLibCheck: true,
          }
        }
      }
    } catch (error) {
      // ‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ
    }

    return defaultOptions
  }

  async analyzeTypeDefinitions() {
    let definitionCount = 0

    // ÂàÜÊûê TypeScript Á®ãÂ∫è
    if (this.program) {
      for (const sourceFile of this.program.getSourceFiles()) {
        if (this.isProjectFile(sourceFile.fileName)) {
          definitionCount += this.visitTypeDefinitions(sourceFile)
        }
      }
    }

    // ÂàÜÊûê Vue Êñá‰ª∂
    for (const file of this.sourceFiles) {
      if (file.endsWith('.vue')) {
        definitionCount += await this.analyzeVueFile(file)
      }
    }

    if (this.options.verbose) {
      console.log(`üìä  ÂèëÁé∞ ${this.typeDefinitions.size} ‰∏™Á±ªÂûãÂÆö‰πâ`)
    }
  }

  isProjectFile(fileName) {
    try {
      const normalizedPath = resolve(fileName).replace(/\\/g, '/')
      
      // ÊéíÈô§Á≥ªÁªüÊñá‰ª∂
      if (normalizedPath.includes('node_modules') ||
          normalizedPath.includes('/lib.') ||
          normalizedPath.includes('typescript/lib')) {
        return false
      }
      
      // Ê£ÄÊü•ÊòØÂê¶ÊòØÈ°πÁõÆÊñá‰ª∂
      return this.sourceFiles.some(file => {
        return resolve(file).replace(/\\/g, '/') === normalizedPath
      })
    } catch (error) {
      return false
    }
  }

  visitTypeDefinitions(sourceFile) {
    let count = 0
    
    const visit = (node) => {
      try {
        if (!node) return
        
        switch (node.kind) {
          case ts.SyntaxKind.InterfaceDeclaration:
            if (this.processInterfaceDeclaration(node, sourceFile)) count++
            break
          case ts.SyntaxKind.TypeAliasDeclaration:
            if (this.processTypeAliasDeclaration(node, sourceFile)) count++
            break
          case ts.SyntaxKind.EnumDeclaration:
            if (this.processEnumDeclaration(node, sourceFile)) count++
            break
          case ts.SyntaxKind.ClassDeclaration:
            if (this.processClassDeclaration(node, sourceFile)) count++
            break
        }
        
        ts.forEachChild(node, visit)
      } catch (error) {
        // ÂøΩÁï•Âçï‰∏™ËäÇÁÇπÂ§ÑÁêÜÈîôËØØ
      }
    }
    
    visit(sourceFile)
    return count
  }

  processInterfaceDeclaration(node, sourceFile) {
    try {
      if (!node || !node.name || !node.name.text) return false
      
      const name = node.name.text
      if (this.shouldIgnoreType(name)) return false

      const info = {
        name,
        type: 'interface',
        file: sourceFile.fileName,
        line: this.getNodeLine(sourceFile, node),
        exported: this.hasExportModifier(node)
      }

      this.addTypeDefinition(name, info)
      return true
    } catch (error) {
      return false
    }
  }

  processTypeAliasDeclaration(node, sourceFile) {
    try {
      if (!node || !node.name || !node.name.text) return false
      
      const name = node.name.text
      if (this.shouldIgnoreType(name)) return false

      const info = {
        name,
        type: 'type',
        file: sourceFile.fileName,
        line: this.getNodeLine(sourceFile, node),
        exported: this.hasExportModifier(node)
      }

      this.addTypeDefinition(name, info)
      return true
    } catch (error) {
      return false
    }
  }

  processEnumDeclaration(node, sourceFile) {
    try {
      if (!node || !node.name || !node.name.text) return false
      
      const name = node.name.text
      if (this.shouldIgnoreType(name)) return false

      const info = {
        name,
        type: 'enum',
        file: sourceFile.fileName,
        line: this.getNodeLine(sourceFile, node),
        exported: this.hasExportModifier(node)
      }

      this.addTypeDefinition(name, info)
      return true
    } catch (error) {
      return false
    }
  }

  processClassDeclaration(node, sourceFile) {
    try {
      if (!node || !node.name || !node.name.text) return false
      
      const name = node.name.text
      if (this.shouldIgnoreType(name)) return false

      const info = {
        name,
        type: 'class',
        file: sourceFile.fileName,
        line: this.getNodeLine(sourceFile, node),
        exported: this.hasExportModifier(node)
      }

      this.addTypeDefinition(name, info)
      return true
    } catch (error) {
      return false
    }
  }

  getNodeLine(sourceFile, node) {
    try {
      const start = node.getStart ? node.getStart() : node.pos
      const position = ts.getLineAndCharacterOfPosition(sourceFile, start)
      return position.line + 1
    } catch (error) {
      return 0
    }
  }

  hasExportModifier(node) {
    try {
      return node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword) || false
    } catch (error) {
      return false
    }
  }

  addTypeDefinition(name, info) {
    try {
      if (this.typeDefinitions.has(name)) {
        const existing = this.typeDefinitions.get(name)
        if (existing.file !== info.file) {
          // ÁúüÊ≠£ÁöÑÈáçÂ§çÂÆö‰πâ
          if (!this.duplicateTypes.has(name)) {
            this.duplicateTypes.set(name, [existing])
          }
          this.duplicateTypes.get(name).push(info)
        }
      } else {
        this.typeDefinitions.set(name, info)
      }
    } catch (error) {
      // ÂøΩÁï•Ê∑ªÂä†ÈîôËØØ
    }
  }

  shouldIgnoreType(typeName) {
    try {
      // ÂÜÖÁΩÆÁ±ªÂûã
      const builtinTypes = [
        'string', 'number', 'boolean', 'object', 'undefined', 'null', 'void',
        'Array', 'Promise', 'Date', 'RegExp', 'Error', 'Function',
        'Record', 'Partial', 'Required', 'Pick', 'Omit'
      ]
      
      if (builtinTypes.includes(typeName)) return true

      // Áî®Êà∑ÂÆö‰πâÁöÑÂøΩÁï•Ê®°Âºè
      return this.options.ignorePatterns.some(pattern => {
        if (pattern instanceof RegExp) {
          return pattern.test(typeName)
        }
        return typeName === pattern || typeName.includes(pattern)
      })
    } catch (error) {
      return false
    }
  }

  async analyzeVueFile(filePath) {
    try {
      const content = readFileSync(filePath, 'utf8')
      const scriptRegex = /<script[^>]*(?:\s+lang=["'](?:ts|typescript)["']|\s+setup)[^>]*>([\s\S]*?)<\/script>/gi
      let count = 0
      let match
      
      while ((match = scriptRegex.exec(content)) !== null) {
        try {
          const scriptContent = match[1]
          const sourceFile = ts.createSourceFile(
            filePath,
            scriptContent,
            ts.ScriptTarget.Latest,
            true,
            ts.ScriptKind.TS
          )
          
          count += this.visitTypeDefinitions(sourceFile)
        } catch (error) {
          // ÂøΩÁï•Âçï‰∏™ script ÂùóÁöÑËß£ÊûêÈîôËØØ
          continue
        }
      }
      
      return count
    } catch (error) {
      return 0
    }
  }

  async analyzeTypeUsages() {
    if (!this.program) return

    try {
      for (const sourceFile of this.program.getSourceFiles()) {
        if (this.isProjectFile(sourceFile.fileName)) {
          this.visitTypeUsages(sourceFile)
        }
      }

      if (this.options.verbose) {
        const totalUsages = Array.from(this.typeUsages.values())
          .reduce((sum, usages) => sum + usages.length, 0)
        console.log(`üîó  ÂèëÁé∞ ${totalUsages} ‰∏™Á±ªÂûãÂºïÁî®`)
      }
    } catch (error) {
      if (this.options.verbose) {
        console.warn('‚ö†Ô∏è  Á±ªÂûã‰ΩøÁî®ÂàÜÊûêÂ§±Ë¥•:', error.message)
      }
    }
  }

  visitTypeUsages(sourceFile) {
    const visit = (node) => {
      try {
        if (!node) return
        
        if (ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName)) {
          const typeName = node.typeName.text
          if (!this.shouldIgnoreType(typeName)) {
            this.addTypeUsage(typeName, {
              file: sourceFile.fileName,
              line: this.getNodeLine(sourceFile, node)
            })
          }
        }
        
        ts.forEachChild(node, visit)
      } catch (error) {
        // ÂøΩÁï•Âçï‰∏™ËäÇÁÇπÈîôËØØ
      }
    }
    
    visit(sourceFile)
  }

  addTypeUsage(typeName, usage) {
    try {
      if (!this.typeUsages.has(typeName)) {
        this.typeUsages.set(typeName, [])
      }
      this.typeUsages.get(typeName).push(usage)
    } catch (error) {
      // ÂøΩÁï•Ê∑ªÂä†ÈîôËØØ
    }
  }

  async detectUnusedTypes() {
    try {
      for (const [typeName, typeInfo] of this.typeDefinitions) {
        const usages = this.typeUsages.get(typeName) || []
        
        // ËøáÊª§ÊéâÂÆö‰πâÂ§ÑÁöÑ"‰ΩøÁî®"
        const realUsages = usages.filter(usage => {
          try {
            const isSameFile = resolve(usage.file) === resolve(typeInfo.file)
            const isNearDefinition = Math.abs(usage.line - typeInfo.line) <= 2
            return !(isSameFile && isNearDefinition)
          } catch (error) {
            return true // ‰øùÂÆàÂ§ÑÁêÜÔºåËÆ§‰∏∫ÊòØÁúüÂÆû‰ΩøÁî®
          }
        })

        if (realUsages.length === 0 && !typeInfo.exported) {
          this.unusedTypes.add(typeName)
        }
      }

      if (this.options.verbose) {
        console.log(`üóëÔ∏è  ÂèëÁé∞ ${this.unusedTypes.size} ‰∏™Êú™‰ΩøÁî®Á±ªÂûã`)
      }
    } catch (error) {
      if (this.options.verbose) {
        console.warn('‚ö†Ô∏è  Êú™‰ΩøÁî®Á±ªÂûãÊ£ÄÊµãÂ§±Ë¥•:', error.message)
      }
    }
  }

  async runTypeChecking() {
    if (!this.program) return

    try {
      const allDiagnostics = ts.getPreEmitDiagnostics(this.program)
      
      for (const diagnostic of allDiagnostics) {
        try {
          if (!diagnostic.file || !this.isProjectFile(diagnostic.file.fileName)) {
            continue
          }

          if (this.isRealTypeError(diagnostic)) {
            const issue = this.createIssueFromDiagnostic(diagnostic)
            
            if (diagnostic.category === ts.DiagnosticCategory.Error) {
              this.errors.push(issue)
            } else if (diagnostic.category === ts.DiagnosticCategory.Warning) {
              this.warnings.push(issue)
            }
          }
        } catch (error) {
          // ÂøΩÁï•Âçï‰∏™ËØäÊñ≠ÁöÑÂ§ÑÁêÜÈîôËØØ
          continue
        }
      }

      if (this.options.verbose) {
        console.log(`üö®  ÂèëÁé∞ ${this.errors.length} ‰∏™Á±ªÂûãÈîôËØØÔºå${this.warnings.length} ‰∏™Ë≠¶Âëä`)
      }
    } catch (error) {
      if (this.options.verbose) {
        console.warn('‚ö†Ô∏è  Á±ªÂûãÊ£ÄÊü•Â§±Ë¥•:', error.message)
      }
    }
  }

  isRealTypeError(diagnostic) {
    // ÁúüÂÆûÁöÑÁ±ªÂûãÈîôËØØ
    const realErrorCodes = [
      2322, // Type 'X' is not assignable to type 'Y'
      2339, // Property 'X' does not exist on type 'Y'
      2345, // Argument of type 'X' is not assignable
      2531, // Object is possibly 'null'
      2532, // Object is possibly 'undefined'
      2571, // Object is of type 'unknown'
    ]

    // ÈÖçÁΩÆÁõ∏ÂÖ≥ÈîôËØØÔºàË∑≥ËøáÔºâ
    const configErrorCodes = [
      2304, // Cannot find name
      2307, // Cannot find module
      1343, // import.meta
      2732, // resolveJsonModule
    ]

    return realErrorCodes.includes(diagnostic.code) && !configErrorCodes.includes(diagnostic.code)
  }

  createIssueFromDiagnostic(diagnostic) {
    try {
      const messageText = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n')
      let line = 0

      if (diagnostic.start !== undefined && diagnostic.file) {
        try {
          const position = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start)
          line = position.line + 1
        } catch (error) {
          line = 0
        }
      }

      return {
        file: diagnostic.file ? diagnostic.file.fileName : '',
        line,
        code: `TS${diagnostic.code}`,
        message: messageText,
        severity: diagnostic.category === ts.DiagnosticCategory.Error ? 'error' : 'warning'
      }
    } catch (error) {
      return {
        file: '',
        line: 0,
        code: 'TS0000',
        message: 'Â§ÑÁêÜËØäÊñ≠‰ø°ÊÅØÊó∂Âá∫Èîô',
        severity: 'error'
      }
    }
  }

  generateReport() {
    try {
      const stats = {
        sourceFiles: this.sourceFiles.length,
        typeDefinitions: this.typeDefinitions.size,
        usageReferences: Array.from(this.typeUsages.values()).reduce((sum, usages) => sum + usages.length, 0),
        unusedTypes: this.unusedTypes.size,
        duplicateDefinitions: this.duplicateTypes.size,
        totalErrors: this.errors.length,
        totalWarnings: this.warnings.length,
      }

      const scores = {
        healthScore: this.calculateHealthScore(),
        validationScore: this.calculateValidationScore(),
      }
      scores.overallScore = Math.round((scores.healthScore + scores.validationScore) / 2)

      return {
        timestamp: new Date().toISOString(),
        statistics: stats,
        scores,
        details: {
          unusedTypes: Array.from(this.unusedTypes),
          duplicates: Object.fromEntries(this.duplicateTypes),
          errors: this.errors,
          warnings: this.warnings,
          typeDefinitions: Object.fromEntries(this.typeDefinitions),
          typeUsages: Object.fromEntries(this.typeUsages),
        },
        suggestions: this.generateSuggestions(),
      }
    } catch (error) {
      throw new Error(`ÁîüÊàêÊä•ÂëäÂ§±Ë¥•: ${error.message}`)
    }
  }

  calculateHealthScore() {
    try {
      const totalTypes = this.typeDefinitions.size
      if (totalTypes === 0) return 100

      let score = 100
      
      const unusedRatio = this.unusedTypes.size / totalTypes
      score -= Math.min(40, unusedRatio * 50)
      
      const duplicateRatio = this.duplicateTypes.size / totalTypes
      score -= Math.min(30, duplicateRatio * 40)

      return Math.max(0, Math.round(score))
    } catch (error) {
      return 50
    }
  }

  calculateValidationScore() {
    try {
      if (this.errors.length === 0) return 100
      
      let score = 100
      score -= this.errors.length * 10
      score -= this.warnings.length * 2

      return Math.max(0, Math.round(score))
    } catch (error) {
      return 50
    }
  }

  generateSuggestions() {
    try {
      const suggestions = []

      if (this.errors.length > 0) {
        suggestions.push(`üî¥  ‰øÆÂ§ç ${this.errors.length} ‰∏™Á±ªÂûãÈîôËØØ`)
      }

      if (this.unusedTypes.size > 0) {
        suggestions.push(`üóëÔ∏è  Ê∏ÖÁêÜ ${this.unusedTypes.size} ‰∏™Êú™‰ΩøÁî®ÁöÑÁ±ªÂûãÂÆö‰πâ`)
      }

      if (this.duplicateTypes.size > 0) {
        suggestions.push(`‚ö†Ô∏è  Â§ÑÁêÜ ${this.duplicateTypes.size} ‰∏™ÈáçÂ§çÁöÑÁ±ªÂûãÂÆö‰πâ`)
      }

      if (suggestions.length === 0) {
        suggestions.push('üéâ  Á±ªÂûãÁ≥ªÁªüÁä∂ÊÄÅËâØÂ•ΩÔºÅ')
      }

      return suggestions
    } catch (error) {
      return ['ÁîüÊàêÂª∫ËÆÆÊó∂Âá∫Èîô']
    }
  }
}

// ÂØºÂá∫‰æøÊç∑ÂáΩÊï∞
export async function analyzeProject(options = {}) {
  const analyzer = new TypeAnalyzer(options)
  return await analyzer.analyze()
}

export async function quickCheck(options = {}) {
  const result = await analyzeProject({ ...options, verbose: false })
  const threshold = options.threshold || 70

  return {
    passed: result.details.errors.length === 0 && result.scores.overallScore >= threshold,
    score: result.scores.overallScore,
    errors: result.details.errors.length,
    warnings: result.details.warnings.length,
    summary: result.details.errors.length === 0 
      ? `‚úÖ  Á±ªÂûãÊ£ÄÊü•ÈÄöËøá (ËØÑÂàÜ: ${result.scores.overallScore}/100)`
      : `‚ùå  ÂèëÁé∞ ${result.details.errors.length} ‰∏™Á±ªÂûãÈîôËØØ`,
  }
}