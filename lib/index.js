import { readFileSync, existsSync, readdirSync, statSync } from 'fs'
import { join, relative, extname, resolve } from 'path'
import ts from 'typescript'

export class TypeAnalyzer {
  constructor(options = {}) {
    this.options = {
      rootDir: options.rootDir || process.cwd(),
      include: options.include || ['src/**/*.{ts,tsx,vue}'],
      exclude: options.exclude || [
        'node_modules', 
        'dist', 
        '.git', 
        'build', 
        'coverage',
        '.cache',
        '.vscode',
        '.idea',
        'test',
        'tests',
        '__tests__',
        '*.d.ts',
        '*.test.ts',
        '*.spec.ts',
        '*.test.tsx',
        '*.spec.tsx'
      ],
      verbose: options.verbose || false,
      ignorePatterns: options.ignorePatterns || [
        /^Props$/, /^Emits$/, /^Slots$/, /^Expose$/,
        /Props$/, /Emits$/, /Events?$/, /State$/
      ],
      ...options,
    }

    this.resetData()
  }

  resetData() {
    this.typeMap = new Map()
    this.usageMap = new Map()
    this.duplicates = new Set()
    this.unusedTypes = new Set()
    this.errors = []
    this.warnings = []
    this.sourceFiles = []
    this.program = null
  }

  async analyze() {
    if (this.options.verbose) {
      console.log('üîç  ÂºÄÂßã TypeScript Á±ªÂûãÂàÜÊûê...')
    }

    try {
      await this.scanFiles()
      await this.initTypeScript()
      await this.analyzeTypes()
      await this.detectUnused()
      await this.runDiagnostics()

      return this.generateReport()
    } catch (error) {
      console.error('‚ùå  ÂàÜÊûêÂ§±Ë¥•:', error.message)
      throw error
    }
  }

  async scanFiles() {
    this.sourceFiles = this.scanDirectory(this.options.rootDir)
      .filter(file => {
        const ext = extname(file)
        return ['.ts', '.tsx', '.vue'].includes(ext)
      })
      .filter(file => {
        const absolutePath = resolve(file)
        const relativePath = relative(this.options.rootDir, file).replace(/\\/g, '/')
        
        // Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•ÊéíÈô§
        return !this.options.exclude.some(pattern => {
          // Â§ÑÁêÜglobÊ®°Âºè
          if (pattern.includes('*')) {
            const regex = new RegExp(
              '^' + pattern
                .replace(/\*\*/g, '.*')
                .replace(/\*/g, '[^/]*')
                .replace(/\./g, '\\.')
                .replace(/\?/g, '.') + '$'
            )
            return regex.test(relativePath)
          }
          
          // Ê£ÄÊü•Ë∑ØÂæÑÊòØÂê¶ÂåÖÂê´ÊéíÈô§Ê®°Âºè
          return relativePath.includes(pattern) || 
                 absolutePath.includes(pattern) ||
                 file.endsWith(pattern)
        })
      })

    if (this.options.verbose) {
      console.log(`üìÑ  Êâ´ÊèèÂà∞ ${this.sourceFiles.length} ‰∏™Ê∫êÊñá‰ª∂`)
    }
  }

  scanDirectory(dir) {
    let files = []
    try {
      const items = readdirSync(dir)
      for (const item of items) {
        const fullPath = join(dir, item)
        
        // Ë∑≥ËøáÂ∏∏ËßÅÁöÑÈùûÊ∫êÁ†ÅÁõÆÂΩï
        if (this.options.exclude.some(pattern => 
          item === pattern || item.startsWith('.')
        )) {
          continue
        }
        
        const stat = statSync(fullPath)
        
        if (stat.isDirectory()) {
          files = files.concat(this.scanDirectory(fullPath))
        } else {
          files.push(fullPath)
        }
      }
    } catch (error) {
      // ÂøΩÁï•ÊùÉÈôêÈîôËØØ
    }
    return files
  }

  async initTypeScript() {
    try {
      const configPath = ts.findConfigFile(
        this.options.rootDir,
        ts.sys.fileExists,
        'tsconfig.json'
      )

      let compilerOptions = {
        target: ts.ScriptTarget.ES2020,
        module: ts.ModuleKind.ESNext,
        esModuleInterop: true,
        skipLibCheck: true,
        skipDefaultLibCheck: true,
        noEmit: true,
        allowJs: true,
        types: [],
        typeRoots: [],
      }

      // Âè™ÂåÖÂê´È°πÁõÆÊ∫êÊñá‰ª∂
      let fileNames = this.sourceFiles.filter(f => {
        const normalizedPath = f.replace(/\\/g, '/')
        return (f.endsWith('.ts') || f.endsWith('.tsx')) &&
               !normalizedPath.includes('node_modules') &&
               !normalizedPath.includes('.d.ts') &&
               !normalizedPath.includes('.test.') &&
               !normalizedPath.includes('.spec.')
      })

      if (configPath) {
        const configFile = ts.readConfigFile(configPath, ts.sys.readFile)
        if (!configFile.error) {
          const parsedConfig = ts.parseJsonConfigFileContent(
            configFile.config,
            ts.sys,
            this.options.rootDir
          )
          
          // ÂêàÂπ∂ÈÄâÈ°π‰ΩÜ‰øùÊåÅÊàë‰ª¨ÁöÑË¶ÜÁõñ
          compilerOptions = { 
            ...parsedConfig.options,
            skipLibCheck: true,
            skipDefaultLibCheck: true,
            noEmit: true,
            types: [],
            typeRoots: [],
          }
        }
      }

      // ÂàõÂª∫Ëá™ÂÆö‰πâÁöÑCompilerHost‰ª•Êõ¥Â•ΩÂú∞ÊéßÂà∂Êñá‰ª∂ËØªÂèñ
      const host = ts.createCompilerHost(compilerOptions)
      const originalGetSourceFile = host.getSourceFile
      
      host.getSourceFile = (fileName, languageVersion, onError, shouldCreateNewSourceFile) => {
        // Ë∑≥ËøáÈùûÈ°πÁõÆÊñá‰ª∂
        if (!this.shouldIncludeFile(fileName)) {
          return undefined
        }
        return originalGetSourceFile.call(host, fileName, languageVersion, onError, shouldCreateNewSourceFile)
      }

      this.program = ts.createProgram(fileNames, compilerOptions, host)
      
      if (this.options.verbose) {
        console.log(`üîß  TypeScript Á®ãÂ∫èÂàùÂßãÂåñÂÆåÊàêÔºåÂåÖÂê´ ${fileNames.length} ‰∏™Êñá‰ª∂`)
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è  TypeScript Á®ãÂ∫èÂàùÂßãÂåñÂ§±Ë¥•:', error.message)
    }
  }

  shouldIncludeFile(fileName) {
    const normalizedPath = fileName.replace(/\\/g, '/')
    
    // ÊéíÈô§Á≥ªÁªüÊñá‰ª∂Âíånode_modules
    if (normalizedPath.includes('node_modules') ||
        normalizedPath.includes('/lib.') ||
        normalizedPath.includes('typescript/lib') ||
        normalizedPath.includes('@types/')) {
      return false
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÊòØÈ°πÁõÆÊñá‰ª∂
    return this.sourceFiles.some(file => {
      const normalizedFile = file.replace(/\\/g, '/')
      return normalizedFile === normalizedPath
    })
  }

  async analyzeTypes() {
    // ÂàÜÊûêTypeScriptÊñá‰ª∂
    if (this.program) {
      for (const sourceFile of this.program.getSourceFiles()) {
        if (this.shouldIncludeFile(sourceFile.fileName)) {
          this.visitNode(sourceFile, sourceFile)
        }
      }
    }

    // ÂàÜÊûêVueÊñá‰ª∂
    const vueFiles = this.sourceFiles.filter(f => f.endsWith('.vue'))
    for (const vueFile of vueFiles) {
      await this.analyzeVueFile(vueFile)
    }

    if (this.options.verbose) {
      console.log(`üîç  ÂàÜÊûêÂÆåÊàêÔºåÂèëÁé∞ ${this.typeMap.size} ‰∏™Á±ªÂûãÂÆö‰πâ`)
    }
  }

  visitNode(node, sourceFile) {
    try {
      switch (node.kind) {
        case ts.SyntaxKind.InterfaceDeclaration:
          this.processInterface(node, sourceFile)
          break
        case ts.SyntaxKind.TypeAliasDeclaration:
          this.processTypeAlias(node, sourceFile)
          break
        case ts.SyntaxKind.EnumDeclaration:
          this.processEnum(node, sourceFile)
          break
        case ts.SyntaxKind.ClassDeclaration:
          this.processClass(node, sourceFile)
          break
        case ts.SyntaxKind.TypeReference:
          this.processTypeReference(node, sourceFile)
          break
      }

      ts.forEachChild(node, child => this.visitNode(child, sourceFile))
    } catch (error) {
      // ÂøΩÁï•Âçï‰∏™ËäÇÁÇπÁöÑÂ§ÑÁêÜÈîôËØØ
      if (this.options.verbose) {
        console.warn(`‚ö†Ô∏è  ËäÇÁÇπÂ§ÑÁêÜË≠¶Âëä: ${error.message}`)
      }
    }
  }

  processInterface(node, sourceFile) {
    const name = node.name.text
    if (this.shouldIgnoreType(name)) return

    const line = ts.getLineAndCharacterOfPosition(sourceFile, node.pos).line + 1
    this.addTypeDefinition(name, {
      type: 'interface',
      file: sourceFile.fileName,
      line,
      exported: this.isExported(node),
    })
  }

  processTypeAlias(node, sourceFile) {
    const name = node.name.text
    if (this.shouldIgnoreType(name)) return

    const line = ts.getLineAndCharacterOfPosition(sourceFile, node.pos).line + 1
    this.addTypeDefinition(name, {
      type: 'type',
      file: sourceFile.fileName,
      line,
      exported: this.isExported(node),
    })
  }

  processEnum(node, sourceFile) {
    const name = node.name.text
    if (this.shouldIgnoreType(name)) return

    const line = ts.getLineAndCharacterOfPosition(sourceFile, node.pos).line + 1
    this.addTypeDefinition(name, {
      type: 'enum',
      file: sourceFile.fileName,
      line,
      exported: this.isExported(node),
    })
  }

  processClass(node, sourceFile) {
    if (!node.name) return
    
    const name = node.name.text
    if (this.shouldIgnoreType(name)) return

    const line = ts.getLineAndCharacterOfPosition(sourceFile, node.pos).line + 1
    this.addTypeDefinition(name, {
      type: 'class',
      file: sourceFile.fileName,
      line,
      exported: this.isExported(node),
    })
  }

  processTypeReference(node, sourceFile) {
    if (ts.isIdentifier(node.typeName)) {
      const typeName = node.typeName.text
      this.addTypeUsage(typeName, {
        file: sourceFile.fileName,
        line: ts.getLineAndCharacterOfPosition(sourceFile, node.pos).line + 1,
      })
    }
  }

  async analyzeVueFile(filePath) {
    try {
      if (!existsSync(filePath)) {
        console.warn(`‚ö†Ô∏è  VueÊñá‰ª∂‰∏çÂ≠òÂú®: ${filePath}`)
        return
      }

      const content = readFileSync(filePath, 'utf8')
      const scriptMatch = content.match(
        /<script[^>]*(?:lang=["']ts["']|setup)[^>]*>([\s\S]*?)<\/script>/i
      )

      if (scriptMatch) {
        const scriptContent = scriptMatch[1]
        const sourceFile = ts.createSourceFile(
          filePath,
          scriptContent,
          ts.ScriptTarget.Latest,
          true,
          ts.ScriptKind.TS
        )
        this.visitNode(sourceFile, sourceFile)
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è  VueÊñá‰ª∂ÂàÜÊûêÂ§±Ë¥• ${filePath}: ${error.message}`)
    }
  }

  shouldIgnoreType(typeName) {
    return this.options.ignorePatterns.some(pattern => {
      if (pattern instanceof RegExp) {
        return pattern.test(typeName)
      }
      return typeName === pattern || typeName.includes(pattern)
    })
  }

  addTypeDefinition(name, info) {
    if (this.typeMap.has(name)) {
      const existing = this.typeMap.get(name)
      if (existing.file !== info.file) {
        this.duplicates.add(name)
      }
    }
    this.typeMap.set(name, info)
  }

  addTypeUsage(typeName, usage) {
    if (!this.usageMap.has(typeName)) {
      this.usageMap.set(typeName, [])
    }
    this.usageMap.get(typeName).push(usage)
  }

  async detectUnused() {
    for (const [typeName, typeInfo] of this.typeMap) {
      if (this.shouldIgnoreType(typeName)) continue

      const usages = this.usageMap.get(typeName) || []
      const realUsages = usages.filter(usage => 
        usage.file !== typeInfo.file || usage.line !== typeInfo.line
      )

      if (realUsages.length === 0 && !typeInfo.exported) {
        this.unusedTypes.add(typeName)
      }
    }

    if (this.options.verbose) {
      console.log(`üîç  Ê£ÄÊµãÂà∞ ${this.unusedTypes.size} ‰∏™Êú™‰ΩøÁî®Á±ªÂûã`)
    }
  }

  async runDiagnostics() {
    if (!this.program) {
      console.warn('‚ö†Ô∏è  TypeScript Á®ãÂ∫èÊú™ÂàùÂßãÂåñÔºåË∑≥ËøáËØäÊñ≠ÂàÜÊûê')
      return
    }

    try {
      // Âè™Ëé∑ÂèñÈ°πÁõÆÊ∫êÊñá‰ª∂ÁöÑËØäÊñ≠
      for (const sourceFile of this.program.getSourceFiles()) {
        // Á°Æ‰øùÂè™Ê£ÄÊü•È°πÁõÆÊñá‰ª∂
        if (!this.shouldIncludeFile(sourceFile.fileName)) {
          continue
        }

        const diagnostics = [
          ...this.program.getSemanticDiagnostics(sourceFile),
          ...this.program.getSyntacticDiagnostics(sourceFile),
        ]

        for (const diagnostic of diagnostics) {
          // Ë∑≥ËøáÁâπÂÆöÁöÑËØäÊñ≠‰ª£Á†Å
          if (this.shouldSkipDiagnostic(diagnostic)) {
            continue
          }

          const messageText = ts.flattenDiagnosticMessageText(
            diagnostic.messageText,
            '\n'
          )

          let file = sourceFile.fileName
          let line = 0

          if (diagnostic.start !== undefined) {
            const position = ts.getLineAndCharacterOfPosition(
              sourceFile,
              diagnostic.start
            )
            line = position.line + 1
          }

          const issue = {
            file,
            line,
            code: `TS${diagnostic.code}`,
            message: messageText,
            severity: diagnostic.category === ts.DiagnosticCategory.Error ? 'error' : 'warning',
          }

          if (diagnostic.category === ts.DiagnosticCategory.Error) {
            this.errors.push(issue)
          } else {
            this.warnings.push(issue)
          }
        }
      }

      if (this.options.verbose) {
        console.log(`üîç  ÂèëÁé∞ ${this.errors.length} ‰∏™ÈîôËØØÔºå${this.warnings.length} ‰∏™Ë≠¶Âëä`)
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è  ËØäÊñ≠ÂàÜÊûêÂ§±Ë¥•:', error.message)
    }
  }

  shouldSkipDiagnostic(diagnostic) {
    // Ë∑≥ËøáÊâæ‰∏çÂà∞Ê®°ÂùóÁöÑÈîôËØØÔºàÈÄöÂ∏∏ÊòØnode_modulesÁõ∏ÂÖ≥Ôºâ
    const skipCodes = [
      2307, // Cannot find module
      2792, // Cannot find module. Did you mean to set the 'moduleResolution'
      7016, // Could not find a declaration file for module
    ]
    
    return skipCodes.includes(diagnostic.code)
  }

  isExported(node) {
    return node.modifiers?.some(
      modifier => modifier.kind === ts.SyntaxKind.ExportKeyword
    )
  }

  generateReport() {
    try {
      const totalFiles = this.sourceFiles.length
      const totalTypes = this.typeMap.size
      const totalUsages = Array.from(this.usageMap.values())
        .reduce((sum, usages) => sum + usages.length, 0)

      // ËÆ°ÁÆóÂàÜÊï∞
      const healthScore = this.calculateHealthScore()
      const validationScore = this.calculateValidationScore()
      const overallScore = Math.round((healthScore + validationScore) / 2)

      return {
        timestamp: new Date().toISOString(),
        statistics: {
          sourceFiles: totalFiles,
          typeDefinitions: totalTypes,
          usageReferences: totalUsages,
          unusedTypes: this.unusedTypes.size,
          duplicateDefinitions: this.duplicates.size,
          totalErrors: this.errors.length,
          totalWarnings: this.warnings.length,
        },
        scores: {
          healthScore,
          validationScore,
          overallScore,
        },
        details: {
          unusedTypes: Array.from(this.unusedTypes),
          duplicates: Array.from(this.duplicates),
          errors: this.errors,
          warnings: this.warnings,
          typeDefinitions: Object.fromEntries(this.typeMap),
          typeUsages: Object.fromEntries(this.usageMap),
        },
        suggestions: this.generateSuggestions(),
      }
    } catch (error) {
      console.error('‚ùå  Êä•ÂëäÁîüÊàêÂ§±Ë¥•:', error.message)
      throw error
    }
  }

  calculateHealthScore() {
    try {
      const totalTypes = this.typeMap.size
      if (totalTypes === 0) return 100

      let score = 100

      // Êú™‰ΩøÁî®Á±ªÂûãÊâ£ÂàÜ (ÊúÄÂ§öÊâ£50ÂàÜ)
      const unusedRatio = this.unusedTypes.size / totalTypes
      const unusedPenalty = Math.min(50, unusedRatio * 60)
      score -= unusedPenalty

      // ÈáçÂ§çÂÆö‰πâÊâ£ÂàÜ (ÊúÄÂ§öÊâ£40ÂàÜ)
      const duplicateRatio = this.duplicates.size / totalTypes
      const duplicatePenalty = Math.min(40, duplicateRatio * 50)
      score -= duplicatePenalty

      return Math.max(0, Math.round(score))
    } catch (error) {
      console.warn('‚ö†Ô∏è  ÂÅ•Â∫∑ÂàÜÊï∞ËÆ°ÁÆóÂ§±Ë¥•:', error.message)
      return 0
    }
  }

  calculateValidationScore() {
    try {
      let score = 100

      // ÂÖ≥ÈîÆÈîôËØØ‰∏•ÈáçÊâ£ÂàÜ
      const criticalErrors = this.errors.filter(e => 
        this.isCriticalError(e.code)
      ).length
      score -= criticalErrors * 15

      // ÊôÆÈÄöÈîôËØØÊâ£ÂàÜ
      const regularErrors = this.errors.length - criticalErrors
      score -= regularErrors * 8

      // Ë≠¶ÂëäËΩªÂæÆÊâ£ÂàÜ
      score -= Math.min(20, this.warnings.length * 1)

      return Math.max(0, Math.round(score))
    } catch (error) {
      console.warn('‚ö†Ô∏è  È™åËØÅÂàÜÊï∞ËÆ°ÁÆóÂ§±Ë¥•:', error.message)
      return 0
    }
  }

  isCriticalError(code) {
    return ['TS2322', 'TS2339', 'TS2304', 'TS2307'].includes(code)
  }

  generateSuggestions() {
    try {
      const suggestions = []

      const criticalErrors = this.errors.filter(e => 
        this.isCriticalError(e.code)
      ).length
      if (criticalErrors > 0) {
        suggestions.push(`üî¥  Á´ãÂç≥‰øÆÂ§ç ${criticalErrors} ‰∏™ÂÖ≥ÈîÆÁ±ªÂûãÈîôËØØ`)
      }

      if (this.unusedTypes.size > 0) {
        suggestions.push(`üí°  Ê∏ÖÁêÜ ${this.unusedTypes.size} ‰∏™Êú™‰ΩøÁî®ÁöÑÁ±ªÂûãÂÆö‰πâ`)
      }

      if (this.duplicates.size > 0) {
        suggestions.push(`‚ö†Ô∏è  ÂêàÂπ∂ ${this.duplicates.size} ‰∏™ÈáçÂ§çÁöÑÁ±ªÂûãÂÆö‰πâ`)
      }

      const unusedImports = this.warnings.filter(w => 
        w.type === 'unused-import'
      ).length
      if (unusedImports > 0) {
        suggestions.push(`üßπ  Ê∏ÖÁêÜ ${unusedImports} ‰∏™Êú™‰ΩøÁî®ÁöÑÂØºÂÖ•`)
      }

      if (suggestions.length === 0) {
        suggestions.push('üéâ  Á±ªÂûãÁ≥ªÁªüÁä∂ÊÄÅËâØÂ•ΩÔºå‰ª£Á†ÅË¥®Èáè‰ºòÁßÄÔºÅ')
      }

      return suggestions
    } catch (error) {
      console.warn('‚ö†Ô∏è  Âª∫ËÆÆÁîüÊàêÂ§±Ë¥•:', error.message)
      return ['Âª∫ËÆÆÁîüÊàêÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Êó•Âøó']
    }
  }
}

// ÂØºÂá∫‰æøÊç∑ÂáΩÊï∞
export async function analyzeProject(options = {}) {
  const analyzer = new TypeAnalyzer(options)
  return await analyzer.analyze()
}

export async function quickCheck(options = {}) {
  const result = await analyzeProject({
    ...options,
    verbose: false,
  })

  const hasErrors = result.details.errors.length > 0
  const score = result.scores.validationScore
  const threshold = options.threshold || 70

  return {
    passed: !hasErrors && score >= threshold,
    score,
    errors: result.details.errors.length,
    warnings: result.details.warnings.length,
    summary: hasErrors 
      ? `‚ùå  ÂèëÁé∞ ${result.details.errors.length} ‰∏™Á±ªÂûãÈîôËØØ`
      : `‚úÖ  Á±ªÂûãÊ£ÄÊü•ÈÄöËøá (ËØÑÂàÜ: ${score}/100)`,
  }
}